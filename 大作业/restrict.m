function [out,newN] = restrict(N,r)
% 限制操作
% 输入：规模N，待限制向量r
% 输出：操作后得到的下一层网格上的向量out，下一层网格的规模newN

% 首先把r转换为2维矩阵，便于操作
for i = 1:N-1
    r2(:,i) = r(1+(i-1)*(N-1):i*(N-1));
end

% 下一网格上某结点的值，由其周围3*3网格的点加权求和得到
% padding = 2， 故下一层网格规模是上一层的二分之一

% 加权策略
% 1/16   1/8   1/16
% 1/8    1/4   1/8
% 1/16   1/8   1/16

tmp = r2(1:2:N-3,1:2:N-3).*(1/16)...
    + r2(1:2:N-3,3:2:N-1).*(1/16)...
    + r2(3:2:N-1,1:2:N-3).*(1/16)...
    + r2(3:2:N-1,3:2:N-1).*(1/16)...
    + r2(1:2:N-3,2:2:N-2).*(1/8)...
    + r2(2:2:N-2,1:2:N-3).*(1/8)...
    + r2(2:2:N-2,3:2:N-1).*(1/8)...
    + r2(3:2:N-1,2:2:N-2).*(1/8)...
    + r2(2:2:N-2,2:2:N-2).*(1/4);

% 得到新的规模
newN = size(tmp,1) + 1;
% 将新的2维矩阵还原回一维向量
for i = 1:newN-1
    out(1+(i-1)*(newN-1):i*(newN-1),1)=tmp(:,i);
end

end

